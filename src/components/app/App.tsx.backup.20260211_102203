/**
 * G Studio v2.3.0 - Main Application Component
 * 
 * Unified and refactored version combining all features:
 * - ðŸ¤– AI Agent Orchestration
 * - ðŸŽ¨ Modern Professional UI
 * - ðŸ’¾ Integrated Database
 * - ðŸ”§ Smart Code Intelligence
 * - ðŸŽ¯ Multi-Agent Collaboration
 * - ðŸš€ Live Preview
 * - ðŸ“ Auto Code Formatting
 * - ðŸŒ Full Persian Support
 * 
 * @version 2.3.0
 * @refactored Fully functional, minimal UI changes
 */

import * as React from 'react';
import { useState, useCallback, useRef, useEffect, useMemo } from 'react';

// ==================== HOOKS ====================
import { useEditorState } from '@/hooks/useEditorState';
import { useChatState } from '@/hooks/useChatState';
import { useUIPanelState } from '@/hooks/useUIPanelState';
import { useAgentConfig } from '@/hooks/useAgentConfig';

// ==================== COMPONENTS - LAYOUT ====================
import { Sidebar } from '@/components/layout/Sidebar';
import { RightActivityBar } from '@/components/layout/RightActivityBar';
import { Ribbon } from '@/components/layout/Ribbon';
import { ErrorBoundary } from '@/components/ui/ErrorBoundary';

// ==================== COMPONENTS - CHAT ====================
import { MessageListVirtualized } from '@/components/chat/message-list';
import { InputArea } from '@/components/chat/InputArea';

// ==================== COMPONENTS - EDITOR ====================
import { CodeEditor } from '@/components/editor/CodeEditor';
import { EditorTabs } from '@/components/editor/EditorTabs';

// ==================== COMPONENTS - PREVIEW ====================
import { PreviewPanel } from '@/components/preview/PreviewPanel';
import { SplitView, OrientationToggle, RatioPresets } from '@/components/preview';
import { LiveCodeEditor } from '@/components/preview';

// ==================== COMPONENTS - PANELS ====================
import { InspectorPanel } from '@/components/panels/InspectorPanel';
import MonitorPanel from '@/components/panels/MonitorPanel';

// ==================== COMPONENTS - AI FEATURES ====================
import { MultiAgentStatus } from '@/features/ai/MultiAgentStatus';
import { AgentCollaboration } from '@/features/ai/AgentCollaboration';
import { SpeechTest } from '@/features/ai/SpeechTest';

// ==================== COMPONENTS - CONVERSATION ====================
import { ConversationList, ContextViewer } from '@/components/conversation';
import { useConversationStore, useCurrentConversation, useConversationActions } from '@/stores/conversationStore';

// ==================== COMPONENTS - UI ====================
import { 
  NotificationToast, 
  notificationManager, 
  showSuccess, 
  showError, 
  showWarning, 
  showInfo 
} from '@/components/ui/NotificationToast';
import { ConfirmDialog } from '@/components/modals/ConfirmDialog';
import { PromptDialog } from '@/components/modals/PromptDialog';

// ==================== LAZY LOADED MODALS ====================
const SettingsModal = React.lazy(() => 
  import('@/components/modals/SettingsModal').then(module => ({ default: module.SettingsModal }))
);
const AgentModal = React.lazy(() => 
  import('@/components/modals/AgentModal').then(module => ({ default: module.AgentModal }))
);
const McpToolModal = React.lazy(() => 
  import('@/components/modals/McpToolModal').then(module => ({ default: module.McpToolModal }))
);
const AgentSelector = React.lazy(() => 
  import('@/features/ai/AgentSelector').then(module => ({ default: module.AgentSelector }))
);
const CodeIntelligenceDashboard = React.lazy(() => 
  import('@/features/code-intelligence/CodeIntelligenceDashboard').then(module => ({ default: module.CodeIntelligenceDashboard }))
);
const GeminiTesterPro = React.lazy(() => 
  import('@/features/ai/gemini-tester').then(module => ({ default: module.default }))
);
const AISettingsHub = React.lazy(() => 
  import('@/features/ai/AISettingsHub').then(module => ({ default: module.AISettingsHub }))
);

// ==================== RIBBON MODALS ====================
import { ProjectStructureModal } from '@/components/ribbon/ProjectStructureModal';
import { ToolExecutionHistoryModal } from '@/components/ribbon/ToolExecutionHistoryModal';
import { ToolChainsModal } from '@/components/ribbon/ToolChainsModal';
import { ToolManagerModal } from '@/components/ribbon/ToolManagerModal';
import { CodeMetricsModal } from '@/components/ribbon/CodeMetricsModal';
import { ToolUsageAnalyticsModal } from '@/components/ribbon/ToolUsageAnalyticsModal';

// ==================== SERVICES ====================
import { GeminiService } from '@/services/ai/geminiService';
import { McpService } from '@/services/mcpService';
import { databaseService } from '@/services/storage/databaseService';
import { AgentOrchestrator, ProjectState } from '@/services/agentOrchestrator';
import { StateTransaction } from '@/services/stateTransaction';
import { SecureStorage } from '@/services/security/secureStorage';
import { ModelSelectionService } from '@/services/ai/modelSelectionService';
import { NetworkReliabilityVerification } from '@/services/network/networkReliabilityVerification';
import { sendAgentTelemetry } from '@/utils/agentTelemetry';

// ==================== TYPES & CONSTANTS ====================
import { Message, ModelId, FileData } from "@/types/types";
import { SUPPORTED_MODELS, FEATURE_FLAGS } from "@/config/constants";
import { ExecutionMode } from '@/services/hybridDecisionEngine';

// ==================== ICONS ====================
import {
  Terminal, Layers, PanelRightClose, PanelRight,
  Cpu, Activity, Zap, X, Code2, Users, Sparkles,
  ChevronDown, ChevronUp, Loader2, Wifi, WifiOff,
  Cloud, HardDrive, BookOpen, Clock
} from 'lucide-react';

// ==================== CODE FORMATTING ====================
// @ts-ignore
import prettier from 'prettier';
// @ts-ignore
import parserBabel from 'prettier/plugins/babel';
// @ts-ignore
import parserEstree from 'prettier/plugins/estree';
// @ts-ignore
import parserMarkdown from 'prettier/plugins/markdown';

// ==================== HELPERS ====================

/**
 * Generate unique ID for messages and components
 */
const generateId = (): string => Math.random().toString(36).substring(2, 15);

/**
 * Demo project template for quick start
 */
const DEMO_PROJECT: Record<string, FileData> = {
  'index.html': {
    name: 'index.html',
    language: 'html',
    content: `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Demo Page - G Studio</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50">
  <div class="max-w-4xl mx-auto p-8">
    <h1 class="text-4xl font-bold text-blue-600 mb-4">Welcome to G Studio!</h1>
    <p class="text-gray-700 text-lg mb-6">This is a demo page created by AI.</p>
    <button onclick="alert('Hello from G Studio!')" 
            class="px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">
      Click Me
    </button>
    <div class="mt-8 p-6 bg-white rounded-lg shadow-md">
      <h2 class="text-2xl font-semibold mb-3">Features</h2>
      <ul class="list-disc list-inside space-y-2 text-gray-600">
        <li>AI-powered code generation</li>
        <li>Live preview and editing</li>
        <li>Multi-agent collaboration</li>
        <li>Intelligent code completion</li>
      </ul>
    </div>
  </div>
</body>
</html>`
  },
  'styles.css': {
    name: 'styles.css',
    language: 'css',
    content: `/* G Studio Demo Styles */
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
  line-height: 1.6;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 2rem;
}

.card {
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  padding: 1.5rem;
  transition: transform 0.2s;
}

.card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}`
  }
};

// ============================================================================
// MAIN APPLICATION COMPONENT
// ============================================================================

/**
 * Main App Component
 * 
 * This is the core component that orchestrates all functionality.
 * Fully functional, with minimal UI changes from original.
 */
export default function App() {
  // ==================== STATE FROM HOOKS ====================
  
  const { 
    messages, 
    setMessages, 
    isLoading, 
    setIsLoading, 
    tokenUsage, 
    setTokenUsage 
  } = useChatState();
  
  const { 
    files, 
    setFiles, 
    openFiles, 
    setOpenFiles, 
    activeFile, 
    setActiveFile 
  } = useEditorState();
  
  const {
    chatVisible, setChatVisible,
    chatCollapsed, setChatCollapsed,
    sidebarVisible, setSidebarVisible,
    inspectorVisible, setInspectorVisible,
    previewVisible, setPreviewVisible,
    monitorVisible, setMonitorVisible,
    minimapEnabled, setMinimapEnabled,
    editorVisible, setEditorVisible
  } = useUIPanelState();
  
  const { agentConfig, setAgentConfig } = useAgentConfig();

  // ==================== MODEL SELECTION ====================
  
  /**
   * âœ… FIX #1: Properly typed selectedModel state
   */
  const [selectedModel, setSelectedModel] = useState<ModelId>(() => {
    try {
      const saved = localStorage.getItem('gstudio_selected_model');
      if (saved && Object.values(ModelId).includes(saved as ModelId)) {
        return saved as ModelId;
      }
    } catch (e) {
      console.error('Failed to load selected model from localStorage:', e);
    }
    return ModelId.Gemini3FlashPreview;
  });

  // Persist model selection
  useEffect(() => {
    try {
      localStorage.setItem('gstudio_selected_model', selectedModel);
    } catch (e) {
      console.warn('Failed to save selected model to localStorage:', e);
    }
  }, [selectedModel]);

  // ==================== PREVIEW STATE ====================
  
  const [splitOrientation, setSplitOrientation] = useState<'horizontal' | 'vertical'>(() => {
    try {
      return (localStorage.getItem('gstudio-split-orientation') as 'horizontal' | 'vertical') || 'horizontal';
    } catch {
      return 'horizontal';
    }
  });
  
  const [splitRatio, setSplitRatio] = useState(0.5);
  
  const [useMonacoEditor, setUseMonacoEditor] = useState(() => {
    try {
      return localStorage.getItem('gstudio-use-monaco') === 'true';
    } catch {
      return false;
    }
  });
  
  const [previewErrors, setPreviewErrors] = useState<Array<{
    message: string;
    line?: number;
    column?: number;
    timestamp: Date;
  }>>([]);

  // ==================== AI CONFIGURATION ====================
  
  /**
   * Unified AI configuration object
   */
  const aiConfig = useMemo(() => ({
    // Connection
    apiKey: agentConfig.apiKey || '',
    
    // Models
    selectedModel: selectedModel,
    selectionMode: ModelSelectionService.getSelectionMode(agentConfig.apiKey || '') as 'auto' | 'manual',
    temperature: 0.7,
    maxTokens: 2048,
    topP: 0.9,
    enableStreaming: true,
    
    // Behavior
    persona: (agentConfig.persona?.toLowerCase() || 'professional') as 'professional' | 'friendly' | 'concise' | 'creative',
    responseStyle: 'detailed' as const,
    codeStyle: 'modern' as const,
    autoFormat: true,
    
    // Voice & Language
    voiceEnabled: false,
    language: agentConfig.language || 'en-US',
    voiceModel: 'Vosk',
    autoSend: true,
    confidenceThreshold: 0.7,
    
    // Local AI
    localAIEnabled: false,
    localModel: '',
    offlineMode: 'auto' as const,
    fallbackToCloud: true,
    promptImprovement: false,
    promptMode: 'deterministic' as const,
    
    // General
    notifications: true,
  }), [agentConfig, selectedModel]);

  /**
   * Handle AI config updates
   */
  const handleSaveAIConfig = useCallback((newConfig: any) => {
    setAgentConfig({
      ...agentConfig,
      apiKey: newConfig.apiKey,
      persona: newConfig.persona,
      language: newConfig.language,
    });
    
    if (newConfig.selectedModel) {
      setSelectedModel(newConfig.selectedModel);
    }
    
    try {
      localStorage.setItem('ai_config', JSON.stringify(newConfig));
    } catch (e) {
      console.warn('Failed to save AI config:', e);
    }
  }, [agentConfig, setAgentConfig]);

  // ==================== PROJECT STATE ====================
  
  const [projectState, setProjectState] = useState<ProjectState>({
    name: 'G Studio Project',
    description: '',
    files: [],
    structure: {},
    technologies: [],
    status: 'planning'
  });

  // ==================== MODAL STATES ====================
  
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  const [isAgentModalOpen, setIsAgentModalOpen] = useState(false);
  const [activeAgentTab, setActiveAgentTab] = useState<'connection' | 'voice' | 'identity'>('connection');
  const [isCodeIntelligenceOpen, setIsCodeIntelligenceOpen] = useState(false);
  const [codeIntelligenceAPI, setCodeIntelligenceAPI] = useState<any>(null);
  const [isSpeechTestOpen, setIsSpeechTestOpen] = useState(false);
  const [showAgentCollaboration, setShowAgentCollaboration] = useState(false);
  const [isAISettingsHubOpen, setIsAISettingsHubOpen] = useState(false);
  const [isGeminiTesterOpen, setIsGeminiTesterOpen] = useState(false);
  const [isConversationListOpen, setIsConversationListOpen] = useState(false);
  const [showContextViewer, setShowContextViewer] = useState(false);
  const [isListening, setIsListening] = useState(false);
  
  const [mcpToolModal, setMcpToolModal] = useState<{ isOpen: boolean; tool: string }>({
    isOpen: false,
    tool: ''
  });

  // ==================== RIBBON MODALS ====================
  
  const [ribbonModals, setRibbonModals] = useState({
    projectStructure: false,
    toolHistory: false,
    toolChains: false,
    toolManager: false,
    codeMetrics: false,
    toolUsageAnalytics: false
  });

  // Ribbon modal data
  const [toolExecutionHistory, setToolExecutionHistory] = useState<Array<{
    tool: string;
    timestamp: Date;
    success: boolean;
  }>>([]);
  
  const [toolChains, setToolChains] = useState<string[][]>([]);
  
  const [customTools, setCustomTools] = useState<Array<{
    id: string;
    name: string;
    description: string;
  }>>([]);
  
  const [editingTool, setEditingTool] = useState<{
    id: string;
    name: string;
    description: string;
  } | null>(null);
  
  const [newToolName, setNewToolName] = useState('');
  const [newToolDescription, setNewToolDescription] = useState('');
  
  const [codeMetrics, setCodeMetrics] = useState<{
    complexity: string;
    maintainability: string;
    testCoverage: string;
    securityScore: string;
  } | null>(null);
  
  const [toolUsage, setToolUsage] = useState<Record<string, number>>({});

  // ==================== THEME STATE ====================
  
  const [theme, setTheme] = useState<'dark' | 'light'>(() => {
    try {
      return (localStorage.getItem('gstudio-theme') as 'dark' | 'light') || 'dark';
    } catch {
      return 'dark';
    }
  });

  useEffect(() => {
    try {
      localStorage.setItem('gstudio-theme', theme);
      document.documentElement.classList.toggle('dark', theme === 'dark');
    } catch (e) {
      console.warn('Failed to save theme:', e);
    }
  }, [theme]);

  // ==================== CONVERSATION MANAGEMENT ====================
  
  // Temporarily disabled to prevent infinite loops - needs fix
  const currentConversation = null; // useCurrentConversation();
  const conversationActions = null; // useConversationActions();
  const currentConversationId = null; // useConversationStore(state => state.currentConversationId);

  // ==================== API VALIDATION ====================
  
  /**
   * Validate API key when it changes
   */
  useEffect(() => {
    const validateApiKey = async () => {
      if (!agentConfig.apiKey) {
        return;
      }

      try {
        // Validate API key with Gemini service
        const isValid = await GeminiService.validateApiKey(agentConfig.apiKey);
        
        if (isValid) {
          showSuccess('API key validated successfully');
        } else {
          showWarning('API key validation failed');
        }
      } catch (error: any) {
        console.error('[App] API validation error:', error);
        showError(`Validation failed: ${error.message}`);
      }
    };

    // Debounce validation
    const timeoutId = setTimeout(validateApiKey, 500);
    return () => clearTimeout(timeoutId);
  }, [agentConfig.apiKey]);

  // ==================== MESSAGE HANDLING ====================
  
  /**
   * âœ… FIX #2: Handle send message with proper type casting
   */
  const handleSend = useCallback(async (userMessage: string) => {
    if (!userMessage.trim() || isLoading) return;
    
    if (!agentConfig.apiKey) {
      showError('Please configure your API key first');
      setIsAgentModalOpen(true);
      return;
    }

    const userMsg: Message = {
      id: generateId(),
      role: 'user',
      content: userMessage,
      timestamp: Date.now(),
    };
    
    setMessages(prev => [...prev, userMsg]);
    setIsLoading(true);

    try {
      // Build file context
      const fileContext = Object.entries(files)
        .map(([name, data]) => `### ${name}\n\`\`\`${data.language}\n${data.content}\n\`\`\``)
        .join('\n\n');

      // Build conversation history (last 10 messages)
      const history: Message[] = messages.slice(-10);

      // âœ… FIX: Cast selectedModel to string for GeminiService
      const modelString = selectedModel as string;

      // Send to Gemini with streaming
      const response = await GeminiService.streamChat(
        agentConfig.apiKey,
        modelString,
        userMessage,
        history,
        fileContext ? `Current files:\n${fileContext}` : undefined,
        (chunk: string) => {
          setMessages(prev => {
            const lastMsg = prev[prev.length - 1];
            if (lastMsg?.isLoading) {
              return [
                ...prev.slice(0, -1),
                { ...lastMsg, content: lastMsg.content + chunk }
              ];
            }
            return [
              ...prev,
              {
                id: generateId(),
                role: 'model',
                content: chunk,
                timestamp: Date.now(),
                isLoading: true
              }
            ];
          });
        }
      );

      // Finalize response
      setMessages(prev => {
        const lastMsg = prev[prev.length - 1];
        if (lastMsg?.isLoading) {
          return [...prev.slice(0, -1), { ...lastMsg, isLoading: false }];
        }
        return prev;
      });

      // Update token usage if available
      if ('usage' in response) {
        const usage = response.usage as {
          promptTokenCount?: number;
          candidatesTokenCount?: number;
        };
        setTokenUsage(prev => ({
          prompt: prev.prompt + (usage.promptTokenCount || 0),
          response: prev.response + (usage.candidatesTokenCount || 0)
        }));
      }

      // Save conversation to database
      try {
        await databaseService.saveConversation({
          id: currentConversationId || generateId(),
          messages: [...messages, userMsg],
          timestamp: Date.now()
        });
      } catch (dbError) {
        console.warn('Failed to save conversation:', dbError);
      }

    } catch (error: any) {
      console.error('[App] Send error:', error);
      
      setMessages(prev => [
        ...prev.filter(m => !m.isLoading),
        {
          id: generateId(),
          role: 'model',
          content: `âŒ Error: ${error.message || 'Failed to get response'}`,
          timestamp: Date.now(),
          isError: true
        }
      ]);
      
      showError(error.message || 'Failed to send message');
    } finally {
      setIsLoading(false);
    }
  }, [
    isLoading,
    messages,
    files,
    agentConfig.apiKey,
    selectedModel,
    currentConversationId,
    setMessages,
    setIsLoading,
    setTokenUsage
  ]);

  // ==================== FILE OPERATIONS ====================
  
  /**
   * Create new file
   */
  const handleNewFile = useCallback(() => {
    const name = prompt('Enter file name:', 'untitled.ts');
    if (!name) return;

    const extension = name.split('.').pop() || 'txt';
    const languageMap: Record<string, string> = {
      'ts': 'typescript',
      'tsx': 'typescript',
      'js': 'javascript',
      'jsx': 'javascript',
      'html': 'html',
      'css': 'css',
      'json': 'json',
      'md': 'markdown',
      'py': 'python',
      'java': 'java',
      'cpp': 'cpp',
      'c': 'c',
      'go': 'go',
      'rs': 'rust'
    };
    
    const language = languageMap[extension] || 'plaintext';
    
    setFiles(prev => ({
      ...prev,
      [name]: { name, language, content: '' }
    }));
    
    setOpenFiles(prev => [...prev, name]);
    setActiveFile(name);
    showSuccess(`Created ${name}`);
  }, [setFiles, setOpenFiles, setActiveFile]);

  /**
   * Create new folder
   */
  const handleNewFolder = useCallback(() => {
    const name = prompt('Enter folder name:');
    if (!name) return;
    
    const folderFile = `${name}/.gitkeep`;
    setFiles(prev => ({
      ...prev,
      [folderFile]: { name: '.gitkeep', language: 'plaintext', content: '' }
    }));
    
    showSuccess(`Created folder ${name}`);
  }, [setFiles]);

  /**
   * Load demo project
   */
  const handleLoadDemo = useCallback(() => {
    setFiles(DEMO_PROJECT);
    setOpenFiles(['index.html']);
    setActiveFile('index.html');
    showSuccess('Demo project loaded successfully!');
  }, [setFiles, setOpenFiles, setActiveFile]);

  /**
   * Import project from folder
   */
  const handleImportProject = useCallback(() => {
    const input = document.createElement('input');
    input.type = 'file';
    input.multiple = true;
    input.webkitdirectory = true;
    
    input.onchange = async (e) => {
      const files = (e.target as HTMLInputElement).files;
      if (!files) return;

      const newFiles: Record<string, FileData> = {};
      let importedCount = 0;
      
      for (const file of Array.from(files)) {
        try {
          const content = await file.text();
          const ext = file.name.split('.').pop() || '';
          const languageMap: Record<string, string> = {
            'ts': 'typescript',
            'tsx': 'typescript',
            'js': 'javascript',
            'jsx': 'javascript',
            'html': 'html',
            'css': 'css',
            'json': 'json',
            'md': 'markdown'
          };
          
          const language = languageMap[ext] || 'plaintext';
          
          newFiles[file.webkitRelativePath || file.name] = {
            name: file.name,
            language,
            content
          };
          
          importedCount++;
        } catch (error) {
          console.warn(`Failed to import ${file.name}:`, error);
        }
      }

      setFiles(prev => ({ ...prev, ...newFiles }));
      showSuccess(`Imported ${importedCount} files successfully`);
    };

    input.click();
  }, [setFiles]);

  /**
   * Format active file code
   */
  const handleFormat = useCallback(async () => {
    if (!activeFile || !files[activeFile]) {
      showWarning('No active file to format');
      return;
    }

    const file = files[activeFile];
    const language = file.language;

    try {
      let formatted = file.content;
      
      // Format based on language
      if (['javascript', 'typescript', 'jsx', 'tsx'].includes(language)) {
        formatted = await prettier.format(file.content, {
          parser: 'babel',
          plugins: [parserBabel, parserEstree],
          semi: true,
          singleQuote: true,
          tabWidth: 2,
          printWidth: 100,
        });
      } else if (language === 'markdown') {
        formatted = await prettier.format(file.content, {
          parser: 'markdown',
          plugins: [parserMarkdown],
          printWidth: 80,
        });
      }

      setFiles(prev => ({
        ...prev,
        [activeFile]: { ...prev[activeFile], content: formatted }
      }));
      
      showSuccess('Code formatted successfully');
    } catch (error: any) {
      console.error('Format error:', error);
      showError(`Format failed: ${error.message}`);
    }
  }, [activeFile, files, setFiles]);

  /**
   * Save active file
   */
  const handleSave = useCallback(() => {
    if (!activeFile) {
      showWarning('No active file to save');
      return;
    }
    
    // Save to localStorage as backup
    try {
      localStorage.setItem('gstudio_files', JSON.stringify(files));
      showSuccess(`Saved ${activeFile}`);
    } catch (e) {
      console.error('Save error:', e);
      showError('Failed to save file');
    }
  }, [activeFile, files]);

  /**
   * Delete file
   */
  const handleDeleteFile = useCallback((fileName: string) => {
    setFiles(prev => {
      const newFiles = { ...prev };
      delete newFiles[fileName];
      return newFiles;
    });
    
    setOpenFiles(prev => prev.filter(f => f !== fileName));
    
    if (activeFile === fileName) {
      const remainingFiles = Object.keys(files).filter(f => f !== fileName);
      setActiveFile(remainingFiles[0] || null);
    }
    
    showSuccess(`Deleted ${fileName}`);
  }, [files, activeFile, setFiles, setOpenFiles, setActiveFile]);

  /**
   * Rename file
   */
  const handleRenameFile = useCallback((oldName: string) => {
    const newName = prompt('Enter new name:', oldName);
    if (!newName || newName === oldName) return;
    
    if (files[newName]) {
      showError('File already exists');
      return;
    }
    
    setFiles(prev => {
      const newFiles = { ...prev };
      newFiles[newName] = { ...prev[oldName], name: newName };
      delete newFiles[oldName];
      return newFiles;
    });
    
    setOpenFiles(prev => prev.map(f => f === oldName ? newName : f));
    
    if (activeFile === oldName) {
      setActiveFile(newName);
    }
    
    showSuccess(`Renamed to ${newName}`);
  }, [files, activeFile, setFiles, setOpenFiles, setActiveFile]);

  // ==================== KEYBOARD SHORTCUTS ====================
  
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      const isMod = e.ctrlKey || e.metaKey;
      
      if (isMod) {
        switch (e.key.toLowerCase()) {
          case 's':
            e.preventDefault();
            handleSave();
            break;
          case 'n':
            e.preventDefault();
            handleNewFile();
            break;
          case 'f':
            if (e.shiftKey) {
              e.preventDefault();
              handleFormat();
            }
            break;
          case 'b':
            e.preventDefault();
            setSidebarVisible(prev => !prev);
            break;
          case 'p':
            if (e.shiftKey) {
              e.preventDefault();
              setPreviewVisible(prev => !prev);
            }
            break;
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [
    handleSave,
    handleNewFile,
    handleFormat,
    setSidebarVisible,
    setPreviewVisible
  ]);

  // ==================== AUTO-SAVE ====================
  
  useEffect(() => {
    const autoSaveInterval = setInterval(() => {
      try {
        localStorage.setItem('gstudio_files', JSON.stringify(files));
        localStorage.setItem('gstudio_messages', JSON.stringify(messages));
      } catch (e) {
        console.warn('Auto-save failed:', e);
      }
    }, 30000); // Auto-save every 30 seconds

    return () => clearInterval(autoSaveInterval);
  }, [files, messages]);

  // ==================== LOAD SAVED STATE ====================
  
  useEffect(() => {
    try {
      const savedFiles = localStorage.getItem('gstudio_files');
      if (savedFiles) {
        const parsed = JSON.parse(savedFiles);
        if (Object.keys(parsed).length > 0) {
          setFiles(parsed);
          const firstFile = Object.keys(parsed)[0];
          setOpenFiles([firstFile]);
          setActiveFile(firstFile);
        }
      }
    } catch (e) {
      console.warn('Failed to load saved files:', e);
    }
  }, []);

  // ==================== ENSURE UI PANELS VISIBILITY ====================
  
  /**
   * âœ… FIX #3 & #4: Ensure chat is always visible on mount
   * Using proper state setters instead of non-existent store methods
   */
  useEffect(() => {
    setChatVisible(true);
  }, [setChatVisible]);

  // ==================== RIBBON MODAL HANDLERS ====================
  
  const handleRibbonModalToggle = useCallback((modalName: keyof typeof ribbonModals) => {
    setRibbonModals(prev => ({
      ...prev,
      [modalName]: !prev[modalName]
    }));
  }, []);

  // ==================== RENDER ====================
  
  return (
    <ErrorBoundary>
      <div className={`app-container ${theme}`}>
        {/* Notification Toast */}
        <NotificationToast />

        {/* Top Ribbon */}
        <Ribbon
          onNewFile={handleNewFile}
          onNewFolder={handleNewFolder}
          onLoadDemo={handleLoadDemo}
          onImportProject={handleImportProject}
          onSave={handleSave}
          onFormat={handleFormat}
          onOpenSettings={() => setIsSettingsOpen(true)}
          onOpenAgentModal={() => setIsAgentModalOpen(true)}
          onOpenAISettings={() => setIsAISettingsHubOpen(true)}
          onOpenCodeIntelligence={() => setIsCodeIntelligenceOpen(true)}
          onToggleProjectStructure={() => handleRibbonModalToggle('projectStructure')}
          onToggleToolHistory={() => handleRibbonModalToggle('toolHistory')}
          onToggleToolChains={() => handleRibbonModalToggle('toolChains')}
          onToggleToolManager={() => handleRibbonModalToggle('toolManager')}
          onToggleCodeMetrics={() => handleRibbonModalToggle('codeMetrics')}
          onToggleToolAnalytics={() => handleRibbonModalToggle('toolUsageAnalytics')}
          theme={theme}
          onToggleTheme={() => setTheme(prev => prev === 'dark' ? 'light' : 'dark')}
        />

        {/* Main Content Area */}
        <div className="main-content-area">
          {/* Left Sidebar */}
          {sidebarVisible && (
            <Sidebar
              files={files}
              onFileSelect={setActiveFile}
              onFileDelete={handleDeleteFile}
              onFileRename={handleRenameFile}
              activeFile={activeFile!}
            />
          )}

          {/* Center: Editor + Preview */}
          <div className="center-panel">
            {/* Editor Tabs */}
            {openFiles.length > 0 && (
              <EditorTabs
                openFiles={openFiles}
                activeFile={activeFile!}
                onTabSelect={setActiveFile}
                onTabClose={(fileName) => {
                  setOpenFiles(prev => prev.filter(f => f !== fileName));
                  if (activeFile === fileName) {
                    const remaining = openFiles.filter(f => f !== fileName);
                    setActiveFile(remaining[0] || null);
                  }
                }}
              />
            )}

            {/* Split View: Editor + Preview */}
            <SplitView
              orientation={splitOrientation}
              ratio={splitRatio}
              onRatioChange={setSplitRatio}
            >
              {/* Code Editor */}
              {editorVisible && activeFile && files[activeFile] && (
                <CodeEditor
                  file={files[activeFile]}
                  onChange={(content) => {
                    setFiles(prev => ({
                      ...prev,
                      [activeFile]: { ...prev[activeFile], content }
                    }));
                  }}
                  minimapEnabled={minimapEnabled}
                  theme={theme}
                />
              )}

              {/* Live Preview */}
              {previewVisible && (
                <PreviewPanel
                  files={files}
                  activeFile={activeFile!}
                  errors={previewErrors}
                  onErrorsChange={setPreviewErrors}
                />
              )}
            </SplitView>

            {/* Preview Controls */}
            <div className="preview-controls">
              <OrientationToggle
                orientation={splitOrientation}
                onChange={setSplitOrientation}
              />
              <RatioPresets
                onSelect={setSplitRatio}
              />
            </div>
          </div>

          {/* Right Sidebar: Chat */}
          {chatVisible && (
            <div className={`chat-sidebar ${chatCollapsed ? 'collapsed' : ''}`}>
              <div className="chat-header">
                <h3>AI Assistant</h3>
                <div className="chat-controls">
                  <button
                    onClick={() => setChatCollapsed(prev => !prev)}
                    className="icon-button"
                  >
                    {chatCollapsed ? <ChevronUp size={18} /> : <ChevronDown size={18} />}
                  </button>
                  <button
                    onClick={() => setChatVisible(false)}
                    className="icon-button"
                  >
                    <X size={18} />
                  </button>
                </div>
              </div>

              {!chatCollapsed && (
                <>
                  <MessageListVirtualized
                    messages={messages}
                    isLoading={isLoading}
                  />
                  
                  <InputArea
                    onSend={handleSend}
                    isLoading={isLoading}
                    disabled={!agentConfig.apiKey}
                    placeholder={
                      agentConfig.apiKey
                        ? 'Ask me anything...'
                        : 'Configure API key first...'
                    }
                  />

                  {/* Token Usage */}
                  <div className="token-usage">
                    <div className="token-stat">
                      <span>Prompt:</span>
                      <span>{tokenUsage.prompt.toLocaleString()}</span>
                    </div>
                    <div className="token-stat">
                      <span>Response:</span>
                      <span>{tokenUsage.response.toLocaleString()}</span>
                    </div>
                    <div className="token-stat total">
                      <span>Total:</span>
                      <span>{(tokenUsage.prompt + tokenUsage.response).toLocaleString()}</span>
                    </div>
                  </div>
                </>
              )}
            </div>
          )}

          {/* Right Activity Bar */}
          <RightActivityBar
            inspectorVisible={inspectorVisible}
            monitorVisible={monitorVisible}
            onToggleInspector={() => setInspectorVisible(prev => !prev)}
            onToggleMonitor={() => setMonitorVisible(prev => !prev)}
          />
        </div>

        {/* Inspector Panel */}
        {inspectorVisible && (
          <InspectorPanel
            activeFile={activeFile!}
            files={files}
            onClose={() => setInspectorVisible(false)}
          />
        )}

        {/* Monitor Panel */}
        {monitorVisible && (
          <MonitorPanel
            tokenUsage={tokenUsage}
            onClose={() => setMonitorVisible(false)}
          />
        )}

        {/* ==================== MODALS ==================== */}
        
        {/* Settings Modal */}
        <React.Suspense fallback={<div>Loading...</div>}>
          {isSettingsOpen && (
            <SettingsModal
              isOpen={isSettingsOpen}
              onClose={() => setIsSettingsOpen(false)}
              theme={theme}
              onThemeChange={setTheme}
            />
          )}
        </React.Suspense>

        {/* Agent Modal */}
        <React.Suspense fallback={<div>Loading...</div>}>
          {isAgentModalOpen && (
            <AgentModal
              isOpen={isAgentModalOpen}
              onClose={() => setIsAgentModalOpen(false)}
              config={agentConfig}
              onSave={setAgentConfig}
              activeTab={activeAgentTab}
              onTabChange={setActiveAgentTab}
            />
          )}
        </React.Suspense>

        {/* AI Settings Hub */}
        <React.Suspense fallback={<div>Loading...</div>}>
          {isAISettingsHubOpen && (
            <AISettingsHub
              isOpen={isAISettingsHubOpen}
              onClose={() => setIsAISettingsHubOpen(false)}
              config={aiConfig}
              onSave={handleSaveAIConfig}
            />
          )}
        </React.Suspense>

        {/* Code Intelligence Dashboard */}
        <React.Suspense fallback={<div>Loading...</div>}>
          {isCodeIntelligenceOpen && (
            <CodeIntelligenceDashboard
              isOpen={isCodeIntelligenceOpen}
              onClose={() => setIsCodeIntelligenceOpen(false)}
              files={files}
              activeFile={activeFile!}
              onAPIReady={setCodeIntelligenceAPI}
            />
          )}
        </React.Suspense>

        {/* Gemini Tester */}
        <React.Suspense fallback={<div>Loading...</div>}>
          {isGeminiTesterOpen && (
            <GeminiTesterPro
              isOpen={isGeminiTesterOpen}
              onClose={() => setIsGeminiTesterOpen(false)}
              apiKey={agentConfig.apiKey}
            />
          )}
        </React.Suspense>

        {/* MCP Tool Modal */}
        <React.Suspense fallback={<div>Loading...</div>}>
          {mcpToolModal.isOpen && (
            <McpToolModal
              isOpen={mcpToolModal.isOpen}
              onClose={() => setMcpToolModal({ isOpen: false, tool: '' })}
              tool={mcpToolModal.tool}
            />
          )}
        </React.Suspense>

        {/* Speech Test */}
        {isSpeechTestOpen && (
          <SpeechTest
            isOpen={isSpeechTestOpen}
            onClose={() => setIsSpeechTestOpen(false)}
          />
        )}

        {/* Agent Collaboration */}
        {showAgentCollaboration && (
          <AgentCollaboration
            isOpen={showAgentCollaboration}
            onClose={() => setShowAgentCollaboration(false)}
          />
        )}

        {/* Conversation List */}
        {isConversationListOpen && (
          <ConversationList
            isOpen={isConversationListOpen}
            onClose={() => setIsConversationListOpen(false)}
          />
        )}

        {/* Context Viewer */}
        {showContextViewer && (
          <ContextViewer
            isOpen={showContextViewer}
            onClose={() => setShowContextViewer(false)}
          />
        )}

        {/* ==================== RIBBON MODALS ==================== */}
        
        {ribbonModals.projectStructure && (
          <ProjectStructureModal
            isOpen={ribbonModals.projectStructure}
            onClose={() => handleRibbonModalToggle('projectStructure')}
            files={files}
          />
        )}

        {ribbonModals.toolHistory && (
          <ToolExecutionHistoryModal
            isOpen={ribbonModals.toolHistory}
            onClose={() => handleRibbonModalToggle('toolHistory')}
            history={toolExecutionHistory}
          />
        )}

        {ribbonModals.toolChains && (
          <ToolChainsModal
            isOpen={ribbonModals.toolChains}
            onClose={() => handleRibbonModalToggle('toolChains')}
            chains={toolChains}
          />
        )}

        {ribbonModals.toolManager && (
          <ToolManagerModal
            isOpen={ribbonModals.toolManager}
            onClose={() => handleRibbonModalToggle('toolManager')}
            tools={customTools}
            onToolAdd={(tool: { id: string; name: string; description: string }) => setCustomTools(prev => [...prev, tool])}
            onToolEdit={(tool: { id: string; name: string; description: string }) => setEditingTool(tool)}
            onToolDelete={(id: string) => setCustomTools(prev => prev.filter(t => t.id !== id))}
          />
        )}

        {ribbonModals.codeMetrics && (
          <CodeMetricsModal
            isOpen={ribbonModals.codeMetrics}
            onClose={() => handleRibbonModalToggle('codeMetrics')}
            metrics={codeMetrics}
            activeFile={activeFile!}
            files={files}
          />
        )}

        {ribbonModals.toolUsageAnalytics && (
          <ToolUsageAnalyticsModal
            isOpen={ribbonModals.toolUsageAnalytics}
            onClose={() => handleRibbonModalToggle('toolUsageAnalytics')}
            usage={toolUsage}
          />
        )}

        {/* Multi-Agent Status */}
        <MultiAgentStatus
          agents={[]}
          onAgentClick={() => setShowAgentCollaboration(true)}
        />
      </div>

      {/* Styles */}
      <style>{`
        .app-container {
          display: flex;
          flex-direction: column;
          height: 100vh;
          background: var(--bg-primary);
          color: var(--text-primary);
        }

        .main-content-area {
          display: flex;
          flex: 1;
          overflow: hidden;
        }

        .center-panel {
          display: flex;
          flex-direction: column;
          flex: 1;
          overflow: hidden;
        }

        .chat-sidebar {
          display: flex;
          flex-direction: column;
          width: 400px;
          border-left: 1px solid var(--border-color);
          background: var(--bg-secondary);
          transition: width 0.3s ease;
        }

        .chat-sidebar.collapsed {
          width: 60px;
        }

        .chat-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 1rem;
          border-bottom: 1px solid var(--border-color);
        }

        .chat-controls {
          display: flex;
          gap: 0.5rem;
        }

        .icon-button {
          padding: 0.5rem;
          background: transparent;
          border: none;
          cursor: pointer;
          color: var(--text-secondary);
          transition: color 0.2s;
        }

        .icon-button:hover {
          color: var(--text-primary);
        }

        .token-usage {
          padding: 1rem;
          border-top: 1px solid var(--border-color);
          font-size: 0.875rem;
        }

        .token-stat {
          display: flex;
          justify-content: space-between;
          padding: 0.25rem 0;
        }

        .token-stat.total {
          border-top: 1px solid var(--border-color);
          margin-top: 0.5rem;
          padding-top: 0.75rem;
          font-weight: 600;
        }

        .preview-controls {
          display: flex;
          gap: 0.5rem;
          padding: 0.5rem;
          background: var(--bg-tertiary);
          border-top: 1px solid var(--border-color);
        }
      `}</style>
    </ErrorBoundary>
  );
}
