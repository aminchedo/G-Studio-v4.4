
/**
 * InputArea Component - Voice Input Interface
 * 
 * RENDERER ROLE:
 * This renderer is responsible for handling client-side speech interaction inside an Electron application.
 * 
 * Main Responsibilities:
 * - Capture user speech input using Chromium's built-in Speech Recognition engine (Web Speech API)
 * - Operate entirely offline, without using any external APIs or cloud services
 * - Convert spoken audio into text internally only, without displaying subtitles or transcripts in the UI
 * - Send the recognized text to an internal AI processing module (local logic or model)
 * - Control speech recognition lifecycle (start, stop, error handling)
 * - Run strictly inside the Electron Renderer process, not the main process
 * - Maintain security by using a preload bridge and avoiding direct Node access
 * - Support Persian (fa-IR) with automatic fallback to English (en-US) if required
 * 
 * The renderer does NOT:
 * - Display live captions or subtitles
 * - Send audio or text to external services
 * - Use third-party speech APIs (no Google, Whisper, Gemini, etc.)
 * 
 * It acts purely as a voice input interface that feeds text into an internal AI system.
 */

import * as React from 'react';
import { useState, useRef, useEffect, useCallback, type FC, type KeyboardEvent } from 'react';
import { Send, Paperclip, X, Loader2, Mic, MicOff, AlertCircle, WifiOff, HardDrive, Cloud, Wifi } from 'lucide-react';
import { useSpeechRecognition } from '../../hooks';
import { UIPatterns, combinePatterns } from "@/types/uiPatterns";
import { ExecutionMode } from '@/services/hybridDecisionEngine';

// Custom detailed icons with more detail
const DetailedIcons = {
  Paperclip: ({ className, style }: { className?: string; style?: React.CSSProperties }) => (
    <svg viewBox="0 0 24 24" fill="none" className={className} style={style}>
      <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48" 
        stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" strokeLinejoin="round" 
        style={{ shapeRendering: 'geometricPrecision' }} />
      <path d="M12 2.5l-1.5 1.5" stroke="currentColor" strokeWidth={1} strokeLinecap="round" opacity={0.4} />
      <path d="M15 5.5l-1.5 1.5" stroke="currentColor" strokeWidth={1} strokeLinecap="round" opacity={0.3} />
    </svg>
  ),
  
  Mic: ({ className, style }: { className?: string; style?: React.CSSProperties }) => (
    <svg viewBox="0 0 24 24" fill="none" className={className} style={style}>
      <rect x="9" y="2" width="6" height="11" rx="3" stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" strokeLinejoin="round" />
      <path d="M5 10v1a7 7 0 0 0 14 0v-1" stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" strokeLinejoin="round" />
      <line x1="12" y1="18" x2="12" y2="22" stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" />
      <line x1="8" y1="22" x2="16" y2="22" stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" />
      <circle cx="12" cy="7" r="1" fill="currentColor" opacity={0.5} />
      <path d="M9 5l1 1M15 5l-1 1" stroke="currentColor" strokeWidth={0.8} strokeLinecap="round" opacity={0.4} />
    </svg>
  ),
  
  MicOff: ({ className, style }: { className?: string; style?: React.CSSProperties }) => (
    <svg viewBox="0 0 24 24" fill="none" className={className} style={style}>
      <rect x="9" y="2" width="6" height="11" rx="3" stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" strokeLinejoin="round" />
      <path d="M5 10v1a7 7 0 0 0 14 0v-1" stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" strokeLinejoin="round" />
      <line x1="12" y1="18" x2="12" y2="22" stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" />
      <line x1="8" y1="22" x2="16" y2="22" stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" />
      <line x1="1" y1="1" x2="23" y2="23" stroke="currentColor" strokeWidth={2} strokeLinecap="round" />
      <circle cx="12" cy="7" r="1" fill="currentColor" opacity={0.5} />
    </svg>
  ),
  
  Send: ({ className, style }: { className?: string; style?: React.CSSProperties }) => (
    <svg viewBox="0 0 24 24" fill="none" className={className} style={style}>
      <path d="M22 2L11 13" stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" strokeLinejoin="round" />
      <path d="M22 2l-7 20-4-9-9-4 20-7z" stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" strokeLinejoin="round" />
      <path d="M15 9l6-6" stroke="currentColor" strokeWidth={1} strokeLinecap="round" opacity={0.5} />
      <circle cx="22" cy="2" r="1.5" fill="currentColor" />
      <path d="M11 13l-2-2" stroke="currentColor" strokeWidth={0.8} strokeLinecap="round" opacity={0.3} />
    </svg>
  ),
  
  Wifi: ({ className, style }: { className?: string; style?: React.CSSProperties }) => (
    <svg viewBox="0 0 24 24" fill="none" className={className} style={style}>
      <path d="M5 12.55a11 11 0 0 1 5.17-2.39" stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" strokeLinejoin="round" />
      <path d="M1.42 9a16 16 0 0 1 21.16 0" stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" strokeLinejoin="round" />
      <path d="M8.53 16.11a6 6 0 0 1 6.95 0" stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" strokeLinejoin="round" />
      <line x1="12" y1="20" x2="12.01" y2="20" stroke="currentColor" strokeWidth={2} strokeLinecap="round" />
      <circle cx="12" cy="20" r="1.5" fill="currentColor" />
      <path d="M5 12.55l1.5-1.5" stroke="currentColor" strokeWidth={1} strokeLinecap="round" opacity={0.4} />
      <path d="M19 12.55l-1.5-1.5" stroke="currentColor" strokeWidth={1} strokeLinecap="round" opacity={0.4} />
    </svg>
  ),
  
  WifiOff: ({ className, style }: { className?: string; style?: React.CSSProperties }) => (
    <svg viewBox="0 0 24 24" fill="none" className={className} style={style}>
      <path d="M5 12.55a11 11 0 0 1 5.17-2.39" stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" strokeLinejoin="round" />
      <path d="M1.42 9a16 16 0 0 1 21.16 0" stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" strokeLinejoin="round" />
      <path d="M8.53 16.11a6 6 0 0 1 6.95 0" stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" strokeLinejoin="round" />
      <line x1="12" y1="20" x2="12.01" y2="20" stroke="currentColor" strokeWidth={2} strokeLinecap="round" />
      <line x1="1" y1="1" x2="23" y2="23" stroke="currentColor" strokeWidth={2} strokeLinecap="round" />
      <circle cx="12" cy="20" r="1.5" fill="currentColor" />
    </svg>
  ),
  
  HardDrive: ({ className, style }: { className?: string; style?: React.CSSProperties }) => (
    <svg viewBox="0 0 24 24" fill="none" className={className} style={style}>
      <line x1="22" y1="12" x2="2" y2="12" stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" />
      <path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z" 
        stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" strokeLinejoin="round" />
      <circle cx="6" cy="16" r="1" fill="currentColor" opacity={0.6} />
      <circle cx="10" cy="16" r="1" fill="currentColor" opacity={0.4} />
      <rect x="14" y="15" width="2" height="2" rx="0.5" fill="currentColor" opacity={0.3} />
    </svg>
  ),
  
  Cloud: ({ className, style }: { className?: string; style?: React.CSSProperties }) => (
    <svg viewBox="0 0 24 24" fill="none" className={className} style={style}>
      <path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z" stroke="currentColor" strokeWidth={1.5} strokeLinecap="round" strokeLinejoin="round" />
      <path d="M8 10a4 4 0 0 1 4-4" stroke="currentColor" strokeWidth={1} strokeLinecap="round" opacity={0.5} />
      <circle cx="12" cy="10" r="0.8" fill="currentColor" opacity={0.4} />
      <path d="M15 7l-1 1M9 7l1 1" stroke="currentColor" strokeWidth={0.8} strokeLinecap="round" opacity={0.3} />
    </svg>
  )
};

export interface InputAreaProps {
  onSend: (text: string, image?: string) => void;
  isLoading: boolean;
  isListening?: boolean;
  onListeningChange?: (listening: boolean) => void;
  language?: string; // Language code for speech recognition (e.g., 'en-US', 'fa-IR')
  voiceCommandMode?: boolean; // If true, auto-send speech results (voice command mode). If false, just add to input.
  currentAIMode?: ExecutionMode | null; // Current AI execution mode
  isOfflineResponse?: boolean; // Whether the response is offline
  disabled?: boolean;
  placeholder?: string;
}

export const InputArea: FC<InputAreaProps> = ({ 
  onSend, 
  isLoading, 
  isListening = false, 
  onListeningChange = () => {},
  language = 'fa-IR', // Default to Persian for Electron on Windows
  voiceCommandMode = false, // Default: don't auto-send, just add to input
  currentAIMode = null,
  isOfflineResponse = false,
  disabled = false,
  placeholder = 'Type a message...',
}) => {
  const [input, setInput] = useState('');
  const [selectedImage, setSelectedImage] = useState<string | null>(null);
  const [backendAvailable, setBackendAvailable] = useState<boolean | null>(null);
  const [detectedLanguage, setDetectedLanguage] = useState<{ name: string; confidence: number } | null>(null);
  const [isMarkdownPreview, setIsMarkdownPreview] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  // Language auto-detection
  const detectLanguage = useCallback((text: string) => {
    if (!text.trim()) {
      setDetectedLanguage(null);
      return;
    }

    const languages: Record<string, string> = {
      'fa-IR': 'Persian',
      'en-US': 'English',
      'ar-SA': 'Arabic',
      'es-ES': 'Spanish',
      'fr-FR': 'French',
      'de-DE': 'German',
      'zh-CN': 'Chinese',
      'ja-JP': 'Japanese',
      'ko-KR': 'Korean',
      'ru-RU': 'Russian',
    };

    // Simple detection based on character patterns
    const persianPattern = /[\u0600-\u06FF]/;
    const arabicPattern = /[\u0600-\u06FF\u0750-\u077F]/;
    const chinesePattern = /[\u4e00-\u9fff]/;
    const japanesePattern = /[\u3040-\u309F\u30A0-\u30FF]/;
    const koreanPattern = /[\uAC00-\uD7AF]/;
    const cyrillicPattern = /[\u0400-\u04FF]/;

    let detected: string = 'en-US';
    let confidence = 50;

    if (persianPattern.test(text)) {
      detected = 'fa-IR';
      confidence = 85;
    } else if (arabicPattern.test(text)) {
      detected = 'ar-SA';
      confidence = 80;
    } else if (chinesePattern.test(text)) {
      detected = 'zh-CN';
      confidence = 85;
    } else if (japanesePattern.test(text)) {
      detected = 'ja-JP';
      confidence = 85;
    } else if (koreanPattern.test(text)) {
      detected = 'ko-KR';
      confidence = 85;
    } else if (cyrillicPattern.test(text)) {
      detected = 'ru-RU';
      confidence = 80;
    } else {
      // Default to English
      detected = 'en-US';
      confidence = 70;
    }

    setDetectedLanguage({ name: languages[detected] || 'Unknown', confidence });
  }, []);

  // Auto-detect language when input changes
  useEffect(() => {
    if (input) {
      detectLanguage(input);
    } else {
      setDetectedLanguage(null);
    }
  }, [input, detectLanguage]);

  const {
    error,
    setError,
    interimTranscript,
    hasSpeechText,
    clearSpeechState
  } = useSpeechRecognition({
    isListening,
    onListeningChange,
    language,
    voiceCommandMode,
    onSend: (text: string) => {
      handleSend(text);
    },
    setInput: (updater: string | ((prev: string) => string)) => {
      setInput(updater);
    }
  });

  // Check backend health on mount
  useEffect(() => {
    const checkBackendHealth = async () => {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 2000); // 2s timeout
        
        const response = await fetch('http://127.0.0.1:7242/health', {
          method: 'GET',
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        setBackendAvailable(response.ok);
      } catch (error) {
        // Backend unavailable - set to false, do NOT block chat
        setBackendAvailable(false);
      }
    };

    checkBackendHealth();
  }, []);

  const handleSend = useCallback(async (textOverride?: string) => {
    const currentInput = textOverride !== undefined ? textOverride : input;
    const textToSend = (currentInput + (interimTranscript ? ' ' + interimTranscript : '')).trim();
    
    if ((!textToSend && !selectedImage) || isLoading) return;
    
    // CRITICAL: Provider availability guard - UI write lock
    // If provider is terminal (QUOTA_EXHAUSTED, degraded, cooldown), block submission
    try {
      const { DegradedMode } = await import('../../services/network/degradedMode');
      if (!DegradedMode.isProviderAvailable('gemini')) {
        // Provider is terminal - do NOT call onSend
        // User-friendly message will be shown by App.tsx guard
        return;
      }
      
      // CRITICAL: Check if API Model Test has been executed and usable models exist
      // This prevents sending requests when no models are available
      const { ModelValidationStore } = await import('../../services/ai/modelValidationStore');
      // Note: We need API key to check, but we can check if test was executed at all
      // For now, rely on App.tsx to handle the blocking, but add defensive check here
    } catch (error) {
      // Silently fail if services not available - allow submission
      console.warn('[InputArea] Failed to check provider availability:', error);
    }
    
    onSend(textToSend, selectedImage || undefined);
    setInput('');
    clearSpeechState();
    setSelectedImage(null);
    if (textareaRef.current) textareaRef.current.style.height = 'auto';
  }, [input, selectedImage, isLoading, onSend, interimTranscript, clearSpeechState]);

  // Speech recognition is now handled by useSpeechRecognition hook
  // All speech recognition logic has been moved to the hook

  const toggleListening = () => {
    // Toggle listening state
    onListeningChange(!isListening);
  };

  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  return (
    <div className="px-0 py-0 bg-transparent relative z-20">
      {error && (
        <div className="mb-3 flex items-center gap-2 text-[11px] font-medium text-burgundy-700 bg-burgundy-50 px-4 py-2.5 rounded-xl border border-burgundy-100 animate-fade-in shadow-sm w-fit mx-auto absolute -top-12 left-0 right-0">
          <AlertCircle strokeWidth={1.5} className="w-3.5 h-3.5" /> {error}
        </div>
      )}

      {/* Language Detection Indicator */}
      {detectedLanguage && input.trim() && (
        <div className="absolute -top-8 left-6 text-[10px] text-slate-400 bg-slate-800/80 px-2 py-1 rounded-lg border border-slate-700">
          Language: {detectedLanguage.name} ({detectedLanguage.confidence}% confidence)
        </div>
      )}
      
      {selectedImage && (
        <div className="absolute -top-24 left-6 animate-fade-in z-10">
          <div className="relative group">
            <img src={selectedImage} alt="preview" className="h-20 w-auto rounded-xl border border-slate-200 shadow-lg" />
            <button 
              onClick={() => setSelectedImage(null)} 
              aria-label="Remove image"
              className="absolute -top-2 -right-2 bg-slate-800 text-white rounded-full p-1.5 hover:bg-slate-900 shadow-md transition-transform hover:scale-110">
              <X strokeWidth={1.5} className="w-3 h-3" />
            </button>
          </div>
        </div>
      )}

      <div className={combinePatterns(
        UIPatterns.chat.inputContainer,
        "flex items-center gap-1.5 border-x-0 border-b-0 rounded-none transition-all shadow-sm hover:shadow-md hover:border-slate-700 focus-within:ring-2 focus-within:ring-purple-500/10 focus-within:border-purple-400/40 focus-within:shadow-md relative overflow-hidden min-h-[18px] bg-gradient-to-r from-slate-800 via-slate-700 to-slate-800 backdrop-blur-md border-slate-700/60"
      )}>
        {/* Very subtle white gradient overlay - very faint */}
        <div className="absolute inset-0 bg-gradient-to-br from-white/3 via-white/1.5 to-white/3 pointer-events-none" />
        
        {/* AI Mode Indicator - Shows current AI mode with phosphorescent green */}
        {currentAIMode && (
          <div 
            className={`absolute top-1 left-1.5 z-10 flex items-center gap-0.5 px-1 py-0.5 rounded-md border shadow-[0_1px_2px_rgba(0,0,0,0.03)] transition-all ${
              currentAIMode === 'HYBRID' 
                ? 'border-white/30 bg-white/10 text-white' 
                : 'border-lime-400/40 bg-lime-500/20 text-lime-300'
            }`}
            title={`AI Mode: ${currentAIMode}${isOfflineResponse ? ' (Offline Response)' : ''}`}
          >
            {currentAIMode === 'OFFLINE' && (
              <DetailedIcons.WifiOff 
                className="w-4 h-4 text-lime-300" 
                style={{ 
                  shapeRendering: 'geometricPrecision',
                  textRendering: 'optimizeLegibility',
                  WebkitFontSmoothing: 'antialiased',
                  MozOsxFontSmoothing: 'grayscale',
                  imageRendering: '-webkit-optimize-contrast',
                  stroke: 'currentColor',
                  strokeOpacity: 1,
                  fill: 'none',
                  vectorEffect: 'non-scaling-stroke'
                }}
              />
            )}
            {currentAIMode === 'LOCAL' && (
              <DetailedIcons.HardDrive 
                className="w-4 h-4 text-lime-300" 
                style={{ 
                  shapeRendering: 'geometricPrecision',
                  textRendering: 'optimizeLegibility',
                  WebkitFontSmoothing: 'antialiased',
                  MozOsxFontSmoothing: 'grayscale',
                  imageRendering: '-webkit-optimize-contrast',
                  stroke: 'currentColor',
                  strokeOpacity: 1,
                  fill: 'none',
                  vectorEffect: 'non-scaling-stroke'
                }}
              />
            )}
            {currentAIMode === 'CLOUD' && (
              <DetailedIcons.Cloud 
                className="w-4 h-4 text-lime-300" 
                style={{ 
                  shapeRendering: 'geometricPrecision',
                  textRendering: 'optimizeLegibility',
                  WebkitFontSmoothing: 'antialiased',
                  MozOsxFontSmoothing: 'grayscale',
                  imageRendering: '-webkit-optimize-contrast',
                  stroke: 'currentColor',
                  strokeOpacity: 1,
                  fill: 'none',
                  vectorEffect: 'non-scaling-stroke'
                }}
              />
            )}
            {currentAIMode === 'HYBRID' && (
              <DetailedIcons.Wifi 
                className="w-2.5 h-2.5" 
                style={{ 
                  shapeRendering: 'geometricPrecision',
                  textRendering: 'optimizeLegibility',
                  WebkitFontSmoothing: 'antialiased',
                  MozOsxFontSmoothing: 'grayscale',
                  imageRendering: '-webkit-optimize-contrast',
                  stroke: '#ffffff',
                  strokeOpacity: 1,
                  fill: 'none',
                  vectorEffect: 'non-scaling-stroke',
                  color: '#ffffff'
                }}
              />
            )}
          </div>
        )}
        
        {/* Backend status indicator (non-intrusive, only if unavailable) */}
        {backendAvailable === false && (
          <div className="absolute top-1 right-1.5 z-10" title="Backend ingest service unavailable - chat will continue normally">
            <DetailedIcons.WifiOff 
              className="w-3.5 h-3.5" 
              style={{ 
                shapeRendering: 'geometricPrecision',
                textRendering: 'optimizeLegibility',
                WebkitFontSmoothing: 'antialiased',
                MozOsxFontSmoothing: 'grayscale',
                imageRendering: '-webkit-optimize-contrast',
                stroke: '#ffffff',
                strokeWidth: '1.2',
                strokeOpacity: 1,
                fill: '#ffffff',
                vectorEffect: 'non-scaling-stroke',
                color: '#ffffff'
              }}
            />
          </div>
        )}
        <div className="flex gap-1 relative z-10">
            <button 
                onClick={() => fileInputRef.current?.click()} 
                aria-label="Attach file"
                className="group/attach relative p-1.5 text-orange-500 hover:text-orange-400 bg-transparent hover:bg-orange-500/15 active:scale-95 rounded-lg transition-all duration-200 shadow-[0_1px_2px_rgba(0,0,0,0.03)]"
                title="Attach File"
            >
              {/* Subtle gradient overlay on hover */}
              <div className="absolute inset-0 bg-gradient-to-br from-orange-500/10 via-transparent to-orange-400/10 opacity-0 group-hover/attach:opacity-100 transition-opacity duration-200 rounded-lg" />
              <DetailedIcons.Paperclip 
                className="w-[22px] h-[22px] text-orange-500 relative z-10 transition-transform duration-200 group-hover/attach:scale-110" 
                style={{ 
                  shapeRendering: 'geometricPrecision',
                  textRendering: 'optimizeLegibility',
                  WebkitFontSmoothing: 'antialiased',
                  MozOsxFontSmoothing: 'grayscale',
                  imageRendering: '-webkit-optimize-contrast',
                  stroke: 'currentColor',
                  strokeOpacity: 1,
                  fill: 'none',
                  vectorEffect: 'non-scaling-stroke'
                }}
              />
            </button>
            <button 
                onClick={(e) => {
                  // Toggle listening on click - real-time typing mode
                  e.preventDefault();
                  e.stopPropagation();
                  if (isLoading) return;
                  
                  if (isListening) {
                    // Stop listening
                    console.log('[InputArea] Click - stopping listening');
                    // Add any remaining interim transcript to input
                    if (interimTranscript && !voiceCommandMode) {
                      setInput(prev => {
                        const cleanPrev = prev.replace(interimTranscript, '').trim();
                        return cleanPrev ? cleanPrev + ' ' + interimTranscript.trim() : interimTranscript.trim();
                      });
                    }
                    clearSpeechState();
                    onListeningChange(false);
                  } else {
                    // Start listening - real-time mode
                    console.log('[InputArea] Click - starting listening (real-time typing)');
                    onListeningChange(true);
                  }
                }}
                disabled={isLoading}
                className={`group/mic relative p-1.5 rounded-lg transition-all duration-200 border shadow-[0_1px_2px_rgba(0,0,0,0.03)] ${
                  isListening 
                    ? 'text-rose-500 hover:bg-rose-500/15 border-rose-500/30 hover:border-rose-500/50 hover:shadow-md hover:shadow-rose-500/20 bg-rose-500/5' 
                    : isLoading
                    ? 'text-slate-400 cursor-not-allowed border-transparent'
                    : 'text-emerald-500 hover:bg-emerald-500/15 border-transparent hover:border-emerald-500/30 hover:shadow-md hover:shadow-emerald-500/10'
                } active:scale-95`}
                title={isListening ? (voiceCommandMode ? "Listening... (Voice Command Mode - Auto-send)" : "Listening... (Text will be added to input)") : isLoading ? "Please wait..." : "Voice Input (Click to start)"}
            >
              {/* Gradient overlay for mic button */}
              {!isLoading && (
                <div className={`absolute inset-0 bg-gradient-to-br ${
                  isListening 
                    ? 'from-rose-500/10 via-transparent to-rose-400/10' 
                    : 'from-emerald-500/10 via-transparent to-emerald-400/10'
                } opacity-0 group-hover/mic:opacity-100 transition-opacity duration-200 rounded-lg`} />
              )}
              {isListening ? (
                <DetailedIcons.MicOff 
                  className="w-[22px] h-[22px] relative z-10 transition-transform duration-200 group-hover/mic:scale-110" 
                  style={{ 
                    shapeRendering: 'geometricPrecision',
                    textRendering: 'optimizeLegibility',
                    WebkitFontSmoothing: 'antialiased',
                    MozOsxFontSmoothing: 'grayscale',
                    imageRendering: '-webkit-optimize-contrast',
                    stroke: 'currentColor',
                    strokeOpacity: 1,
                    fill: 'none',
                    vectorEffect: 'non-scaling-stroke'
                  }}
                />
              ) : (
                <DetailedIcons.Mic 
                  className="w-[22px] h-[22px] relative z-10 transition-transform duration-200 group-hover/mic:scale-110" 
                  style={{ 
                    shapeRendering: 'geometricPrecision',
                    textRendering: 'optimizeLegibility',
                    WebkitFontSmoothing: 'antialiased',
                    MozOsxFontSmoothing: 'grayscale',
                    imageRendering: '-webkit-optimize-contrast',
                    stroke: 'currentColor',
                    strokeOpacity: 1,
                    fill: 'none',
                    vectorEffect: 'non-scaling-stroke'
                  }}
                />
              )}
            </button>
        </div>
        
        <input type="file" accept="image/*" className="hidden" ref={fileInputRef} onChange={(e) => { 
            const f = e.target.files?.[0]; 
            if (f) { const r = new FileReader(); r.onloadend = () => setSelectedImage(r.result as string); r.readAsDataURL(f); } 
        }} />

        <textarea 
          ref={textareaRef} 
          value={isListening && interimTranscript ? (input + (input ? ' ' : '') + interimTranscript) : input} 
          onChange={(e) => { setInput(e.target.value); e.target.style.height = 'auto'; e.target.style.height = `${e.target.scrollHeight}px`; }}
          onKeyDown={handleKeyDown}
          onDoubleClick={(e) => {
            // Copy text to clipboard on double click
            const textarea = e.target as HTMLTextAreaElement;
            const text = textarea.value;
            if (text.trim()) {
              navigator.clipboard.writeText(text).then(() => {
                // Show visual feedback
                const selection = window.getSelection();
                if (selection) {
                  selection.selectAllChildren(textarea);
                }
                // Optional: Show toast notification
                console.log('[InputArea] Text copied to clipboard');
              }).catch(err => {
                console.error('[InputArea] Failed to copy text:', err);
              });
            }
          }}
          placeholder={isListening ? (voiceCommandMode ? "Listening... (Voice command mode - auto-send)" : "Listening... (Text will be added to input)") : "Ask Gemini to analyze code or run commands..."}
          rows={1} 
          disabled={isLoading}
          lang="en"
          dir="ltr"
          className={combinePatterns(
            UIPatterns.input.base,
            "flex-1 bg-transparent resize-none py-0.5 px-2 text-[11px] max-h-32 leading-relaxed relative z-10 placeholder:text-slate-400 placeholder:opacity-60 no-scrollbar",
            (isListening && interimTranscript && !voiceCommandMode) || hasSpeechText
              ? 'text-amber-400 font-bold' // Golden glowing text for speech-to-text
              : 'text-slate-100' // Normal text - brighter for visibility
          )}
          style={{
            fontFamily: (isListening && interimTranscript && !voiceCommandMode) || hasSpeechText
              ? 'Vazir, Tahoma, Arial, sans-serif' 
              : undefined,
            fontSize: (isListening && interimTranscript && !voiceCommandMode) || hasSpeechText
              ? '14px'
              : undefined,
            letterSpacing: (isListening && interimTranscript && !voiceCommandMode) || hasSpeechText
              ? '0.5px'
              : undefined,
            lineHeight: (isListening && interimTranscript && !voiceCommandMode) || hasSpeechText
              ? '1.8'
              : undefined,
            textShadow: (isListening && interimTranscript && !voiceCommandMode) || hasSpeechText
              ? '0 0 8px rgba(217, 119, 6, 0.4), 0 0 16px rgba(217, 119, 6, 0.2)'
              : undefined,
            filter: (isListening && interimTranscript && !voiceCommandMode) || hasSpeechText
              ? 'drop-shadow(0 0 4px rgba(217, 119, 6, 0.3))'
              : undefined,
            scrollbarWidth: 'none',
            msOverflowStyle: 'none'
          }}
        />

        <button 
          onClick={() => {
            // #region agent log
            // Only send ingest if backend is available
            if (backendAvailable !== false) {
              fetch('http://127.0.0.1:7242/ingest/e36303ce-b8c8-4c86-ba1c-f20c8832334e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'InputArea.tsx:283',message:'Send button clicked',data:{hasInput:!!input.trim(),isLoading,hasImage:!!selectedImage},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'G'})}).catch(()=>{});
            }
            // #endregion
            handleSend();
          }} 
          disabled={isLoading}
          aria-label={isLoading ? "Sending message" : "Send message"}
          aria-disabled={isLoading ? 'true' : 'false'}
          className={`group/send relative p-1.5 rounded-lg transition-all duration-200 active:scale-95 shadow-[0_1px_2px_rgba(0,0,0,0.03)] ${
            isLoading 
              ? 'text-slate-400 cursor-not-allowed' 
              : (!input.trim() && !interimTranscript.trim() && !selectedImage)
              ? 'text-slate-400 hover:text-blue-500 hover:bg-blue-500/10'
              : 'text-blue-500 hover:text-blue-400 hover:bg-blue-500/15 bg-blue-500/5'
          }`}
        >
          {/* Gradient overlay for send button */}
          {!isLoading && (input.trim() || interimTranscript.trim() || selectedImage) && (
            <div className="absolute inset-0 bg-gradient-to-br from-blue-500/10 via-transparent to-blue-400/10 opacity-0 group-hover/send:opacity-100 transition-opacity duration-200 rounded-lg" />
          )}
          {isLoading ? (
            <Loader2 
              strokeWidth={1.5}
              strokeLinecap="round"
              strokeLinejoin="round"
              className="w-[22px] h-[22px] text-blue-500 animate-spin relative z-10" 
              style={{ 
                shapeRendering: 'geometricPrecision',
                textRendering: 'optimizeLegibility',
                WebkitFontSmoothing: 'antialiased',
                MozOsxFontSmoothing: 'grayscale',
                imageRendering: '-webkit-optimize-contrast',
                stroke: 'currentColor',
                strokeOpacity: 1,
                fill: 'none',
                vectorEffect: 'non-scaling-stroke'
              }}
            />
          ) : (
            <DetailedIcons.Send 
              className="w-[22px] h-[22px] text-blue-500 relative z-10 transition-transform duration-200 group-hover/send:scale-110 group-hover/send:translate-x-0.5" 
              style={{ 
                shapeRendering: 'geometricPrecision',
                textRendering: 'optimizeLegibility',
                WebkitFontSmoothing: 'antialiased',
                MozOsxFontSmoothing: 'grayscale',
                imageRendering: '-webkit-optimize-contrast',
                stroke: 'currentColor',
                strokeOpacity: 1,
                fill: 'none',
                vectorEffect: 'non-scaling-stroke'
              }}
            />
          )}
        </button>
      </div>
    </div>
  );
};

